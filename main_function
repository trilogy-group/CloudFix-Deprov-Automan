import re
import requests
import os
import openai
from dotenv import load_dotenv
from openai import OpenAI
from google.oauth2.service_account import Credentials
import datetime
from datetime import datetime, timezone
import base64
import gspread
from gspread.exceptions import APIError
import json
import time
import boto3
from boto3.dynamodb.conditions import Key
from datetime import datetime, timedelta
import pytz

import mysql.connector
import sys
import logging
import pymysql

# Initialize the logger
Status = ""

#Authentication
...
#Google Sheet Setup
SCOPES = ['https://www.googleapis.com/auth/spreadsheets']
SPREADSHEET_ID = '1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY'
SHEET_NAME = 'CF-DeprovAutomanLog'
CREDENTIALS_FILE = 'gssecret001.json' #Use just "gssecret001.json" for Lambda While "D:\Trilogy\My Scripts\SC Automation\gssecret001.json" for local troubleshooting
gscredentials = Credentials.from_service_account_file(CREDENTIALS_FILE, scopes=SCOPES)

# Load the environment variables from the .env file
load_dotenv()

# Set the OpenAI API key from the environment variable
openai.api_key = OPENAI_API_KEY
client = openai.OpenAI(api_key=OPENAI_API_KEY)

def lambda_handler(event, context):
    
    ############################################################################################################       
    #### PRE INITIALIZATION ####
    ############################################################################################################         
    
    #Initialize Old variables
    partition_key_name = 'ticket_number'
    ticket_number = None
    table_name = 'SC_Automan_Reruns'
    status= "Lambda Re-Run Stopped by Dynamo DB Check" # default comment when open sc ==1 or this becomes opening comment for multiopen  sc when open sc>1
    credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
    date_time = "0000-00-00T00:00:00.000Z"
    
    #Initialize New variables
    ticket_number = None
    auth_string = None
    followup_ticket = False
    followup_ticket_number = None
    ticketDescription = ""
    response = ""
    extracted_data = {}
    date_str = ""
    cursor = ""
    user_id = ""
    filename = "clean_and_conform_extracted_date.txt"
    global_gpt_reply = ""
    gpt_date = ""
    ticket_description_text = ""
    extracted_expiry_date = ""
    extracted_company_name = ""
    extracted_email = ""

    
    # Define possible date formats
    date_formats = [
        "%b %d, %Y",  # Jan 01, 2023
            "%d/%m/%Y",   # 01/01/2023
            "%Y-%m-%d",   # 2023-01-01
            "%m/%d/%Y",   # 01/01/2023
            "%d-%m-%Y",   # 01-01-2023
            "%d %b %Y",   # 01 Jan 2023
            "%d %B %Y",   # 01 January 2023
            "%B %d, %Y",  # January 01, 2023
            "%Y.%m.%d",   # 2023.01.01
            "%Y/%m/%d",   # 2023/01/01
            "%Y %b %d",   # 2023 Jan 01
            "%Y %B %d",   # 2023 January 01
            "%d/%m/%y",   # 01/01/23 (two-digit year)
            "%m/%d/%y",   # 01/01/23
        ]
    
    #Determine Current Time
    current_time = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + 'Z' # Get the current time in UTC
    current_time_str = ''.join(current_time) # Convert the current time to a string
    current_time_new = datetime.fromisoformat(current_time_str.strip('Z')).replace(microsecond=0)
    print('Current Time:', current_time_new)
    
    dynamodb = boto3.client(
        'dynamodb',
        aws_access_key_id=aws_access_key_id,
        aws_secret_access_key=aws_secret_access_key,
        region_name=region_name
    )
    
    ############################################################################################################       
    #### INITIAL FUNCTIONS ####
    ############################################################################################################     
    
    #Function to get the worksheet
    def get_worksheet(gscredentials):
        try:
            gc = gspread.authorize(gscredentials)
            sh = gc.open_by_key('1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY')
            worksheet = sh.worksheet('Sheet1')
            return worksheet
        except APIError as e:
            if 'APIError' in str(e):
                print("Google API error, ignoring...")
            else:
                raise  # Re-raise the exception if it's not a quota exceeded error
    
    #Function to write to GSHEET
    def write_to_gsheet(gscredentials, current_time, ticket_number, status):
        try:
            worksheet = get_worksheet(gscredentials)
            row_data = [current_time, ticket_number, status]
            worksheet.append_row(row_data)
        except APIError as e:
            if 'APIError' in str(e):
                print("Google API error, ignoring writing to google sheet and moving on...")
            else:
                raise  # Re-raise the exception if it's not a quota exceeded error
    
    
    #Function to Make the ticket Open
    def put_ticket_on_open(credentials, ticket_number, comment):
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "open",    
                "comment": {
                    "body": (
                        f"CF Automan: {comment}"
                    ),
                    "public": False
                }
            }
        }
        
        update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
        update_response = requests.put(update_url, headers=headers, json=jsonBody)
        
        if update_response.status_code == 200:
            pass
            #print("PUT API for opening the ticket succeeded")
        else:
            print(f"PUT API for opening the ticket failed: {update_response.status_code}")
            print(f"Response content: {update_response.content}")

    #Function to Make the Solved with a Public Comment
    def put_ticket_on_solved_pr(credentials, ticket_number, comment):
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "status": "closed",
                "comment": {
                    "body": (
                        f"CF Automan: {comment}"
                    ),
                    "public": True
                    }
            }
        }
        
        update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
        update_response = requests.put(update_url, headers=headers, json=jsonBody)
        
        if update_response.status_code == 200:
            pass
            print("PUT API for opening the ticket succeeded")
        else:
            print(f"PUT API for opening the ticket failed: {update_response.status_code}")
            print(f"Response content: {update_response.content}")
            
    def put_ticket_on_solved_pr_customer(credentials, ticket_number, comment):
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }

        jsonBody = {
            "ticket": {
                "email_cc_ids": [16482845670802], #16482845670802 Bill Gleeson Cloudfix Email ID
                "collaborator_ids": [16482845670802], #16482845670802 Bill Gleeson Cloudfix Email ID
                "status": "closed",
                "comment": {
                    "body": (
                        f"{comment}"
                    ),
                    "public": True
                    }
            }
        }
        
        update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/update_many.json?ids={ticket_number}"
        update_response = requests.put(update_url, headers=headers, json=jsonBody)
        
        if update_response.status_code == 200:
            pass
            print("PUT API for opening the ticket succeeded")
        else:
            print(f"PUT API for opening the ticket failed: {update_response.status_code}")
            print(f"Response content: {update_response.content}")
    
    #update Ticket Requester
    def update_requester(credentials, ticket_number, extracted_email):
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Basic {credentials}"
        }

        # # Step 1: Search for the user by email
        # contact_email = extracted_email
        
        search_url = f"https://central-supportdesk.zendesk.com/api/v2/users/search.json?query=type:user email:\"{extracted_email}\""
        search_response = requests.get(search_url, headers=headers)

        if search_response.status_code == 200 and search_response.json()['count'] > 0:
            user_id = search_response.json()['users'][0]['id']
            print("User found:", user_id)
        else:
            # Step 2: Create the user if they don't exist
            create_user_url = "https://central-supportdesk.zendesk.com/api/v2/users.json"
            user_data = {
                "user": {
                    "name": extracted_email,  # Use full name if available, otherwise use email
                    "email": extracted_email
                }
            }
            create_response = requests.post(create_user_url, headers=headers, json=user_data)
            if create_response.status_code == 201:
                user_id = create_response.json()['user']['id']
            else:
                print("Error creating user:", create_response.text)
                return False

        # Step 3: Update the ticket with the requester_id
        jsonBody = {
            "ticket": {
                "requester_id": user_id,
                }
            }

        update_url = f"https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json"
        update_response = requests.put(update_url, headers=headers, json=jsonBody)

        if update_response.status_code == 200:
            print("Ticket updated successfully.")
            return True
        else:
            print("Error updating ticket:", update_response.text)
            return False
        
    def get_last_entries(ticket_number):
        response = dynamodb.query(
            TableName=table_name,
            KeyConditionExpression= f"{partition_key_name} = :pkval",
            ExpressionAttributeValues={
                ':pkval': {'S': partition_key_value}
            },
            Limit=10,
            ScanIndexForward=False,  # To get the latest entries first
            ProjectionExpression='ticket_number, date_time'  # Adjust if your attribute names are different
        )
        return response.get('Items', [])
    
    def is_ticket_recent(ticket_number, entries, time_limit_seconds=100):
        now = datetime.now(timezone.utc)
        now = datetime.utcnow().replace(tzinfo=pytz.UTC)
        for entry in entries:
            if entry['ticket_number']['S'] == ticket_number:
                entry_time = datetime.strptime(entry['date_time']['S'], '%Y-%m-%dT%H:%M:%S.%fZ').replace(tzinfo=pytz.UTC)
                if (now - entry_time).total_seconds() <= time_limit_seconds:
                    return True
        return False
    
    def append_entry(ticket_number):
        now = datetime.now(timezone.utc).strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        now = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        #print(f"Adding item to DynamoDB: ticket_number={ticket_number}, date_time={now}")
        dynamodb.put_item(
            TableName=table_name,
            Item={
                partition_key_name: {'S': partition_key_value},
                'date_time': {'S': now}
            }
        )

    ############################################################################################################       
    #### Parse Incoming JSON and Authenticate ####
    ############################################################################################################     
    
    try:    
        # Parse the incoming JSON payload
        if 'body' in event and event['body']:
            body = json.loads(event['body'])
            ticket_number = body.get('ticket_number')
            auth_string = body.get('auth_string')
            if not ticket_number or not auth_string:
                raise ValueError("No ticket number or auth provided in the request body")
            print('Ticket Number:', ticket_number)
        else:
            raise ValueError("Invalid ticket number or auth provided Issue")
        
        # Authenticate the request
        if auth_string == "gskoajdfgk783465FHJgrndY7^^(b_455":
            pass
        else:
            print("Invalid auth provided in the request body")
            raise ValueError("Invalid auth")


        ############################################################################################################       
        #### DOUBLE RUN CHECK USING DBB WITH PRE INITIALIZATION ####
        ############################################################################################################     
        
        # Check if the ticket_number exists in the table
        try:
            partition_key_value = ticket_number
            if not partition_key_value:
                raise ValueError("ticket_number is missing or None")
    
            response = dynamodb.get_item(
                TableName=table_name,
                Key={
                    'ticket_number': {'S': ticket_number},
                    'date_time': {'S': date_time} 
                }
            )
            # Check if the item is found
            if 'Item' in response:
                print("Successfully retrieved item from DynamoDB")
            else:
                print("No item found in DynamoDB for the given ticket_number")
        except dynamodb.exceptions.ResourceNotFoundException:
            print(f"Table {table_name} not found")
        except Exception as e:
            print(f"Error retrieving item: {e}")

        # Proceed with the double run check
        last_entries = get_last_entries(ticket_number)
        if is_ticket_recent(ticket_number, last_entries):
            raise Exception(f"Multiple runs detected for ticket number {ticket_number} and stopped using DBB.")
        else:
            append_entry(ticket_number)
            print(f"Ticket number {ticket_number} has been added. Continuing script.")
        
        ############################################################################################################
        #### MAIN FUNCTIONS ####
        ############################################################################################################     
        
        #Function to get the Scheduler Sheet             
        def get_scheduler_worksheet(gscredentials):
            try:
                gc = gspread.authorize(gscredentials)
                sh = gc.open_by_key('1p2_qDgt8CwL3_hB5vEdKba3XC4TAbm8CL7IOS-lAeEg')
                worksheet = sh.worksheet('Sheet1')
                return worksheet
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error When Getting Followup Scheduler sheet")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
        
        #Function to write to Scheduler GSHEET
        def write_to_scheduler_gsheet(gscredentials, ticket_number, followup_date):
            try:
                worksheet = get_scheduler_worksheet(gscredentials)
                row_data = [followup_date, ticket_number, 'CloudFix Deprovisioning Automan', 'Scheduled']
                worksheet.append_row(row_data)
            except APIError as e:
                if 'APIError' in str(e):
                    print("Google API error, writing to scheduler google sheet")
                else:
                    raise  # Re-raise the exception if it's not a quota exceeded error
            
        def is_future_date(extracted_expiry_date):
            for date_format in date_formats:
                extracted_expiry_date = str(extracted_expiry_date)
                try:
                    date_obj = datetime.strptime(extracted_expiry_date, date_format)
                    return date_obj > datetime.now()
                except ValueError:
                    continue  # Try the next format
            
            # If none of the formats match, raise an error
            raise ValueError(f"Date format for '{extracted_expiry_date}' is not recognized.")

        def deprovision_instance(cursor, extracted_company_name):
            cursor.execute(f'SELECT id, company_name FROM tenants WHERE company_name LIKE "%{extracted_company_name}%"')
            result = cursor.fetchall()
            print('Search results in DB for the company name', result)
            if result and len(result) == 1:
                tenant_id = result[0][0]
                cursor.execute(f"UPDATE tenants SET entitlement_tier = NULL, pricing_plan_id = 4 WHERE id = {tenant_id}")
                result = cursor.fetchall()
                print('updated',result)

                cursor.execute(f'SELECT id, company_name, entitlement_tier, pricing_plan_id FROM tenants WHERE id = {tenant_id}')
                result = cursor.fetchall()
                print('Search results in DB after update', result)
                #result= [f"ID: {item[0]}, Name: {item[1]}" for item in result]
                #print("validating", "\n".join(result))
                if result[0][3]==4:
                    comment = (
                        f"Dear Customer,\n\n"
                        f"Your subscription for {extracted_company_name} to CloudFix has been canceled. We understand that circumstances can change, and we're here to help you through this transition.\n\n"
                        "IMPORTANT: To Prevent Unwanted Charges\n"
                        "Please ensure you've also canceled your subscription through the AWS Marketplace. You can easily do this by following the steps in AWS's \"Cancel the software subscription\" section.\n\n"
                        "Your Data Stays with You\n"
                        "We've set your CloudFix portal to \"view only\" mode. This means you can still access and monitor your saving recommendations. Should you decide to re-engage with us for automated fixes, upgrading your subscription is straightforward.\n\n"
                        "Prefer to Delete Your Data?\n"
                        "If you choose to have all your data removed from our servers, simply reply to this email. We're ready to assist you with this process.\n\n"
                        "Removing CloudFix from Your AWS Organization\n"
                        "If you wish to uninstall CloudFix from your AWS setup completely, here are the steps: How to Remove the CloudFix CloudFormation Stack\n\n"
                        "We're genuinely sorry to see you go. Your journey with CloudFix has been valued, and we are hopeful that our paths will cross again in the future. If you have any feedback or questions, please don't hesitate to reach out.\n\n"
                        "Best regards,\n"
                        "CloudFix Support Team"
                    )
                    update_requester(credentials, ticket_number, extracted_email)
                    put_ticket_on_solved_pr_customer(credentials, ticket_number, comment)
                    status= "CF Automan found the necessary information to proceed with the CloudFix Cancellation."
                    write_to_gsheet(gscredentials, current_time, ticket_number, status)
                    return True
                else:
                    comment = "Hmm, I couldn't complete the deprovisioning! So, I am leaving the ticket open for manually completing this task by an agent. Please share feedback in the log linked here so I can understand what happened and learn from it: [CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
                    put_ticket_on_open(credentials, ticket_number, comment)
                    status= "CF Automan couldn't complete the deprovisioning. Leaving the ticket open for manual completion."
                    write_to_gsheet(gscredentials, current_time, ticket_number, status)
                    return False
            
            elif result and len(result) > 1:
                print(f"Multiple company names for '{extracted_company_name}' found in the database.")
                comment = (
                    f"I found the following companies when searching for '{extracted_company_name}' in our Database!\n\n"
                    f"{result}\n\n"
                    "So, I am leaving the ticket open for manually completing this task by an agent. "
                    "Please share feedback in the log linked here so I can understand what happened and learn from it: "
                    "[CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
                    )
                put_ticket_on_open(credentials, ticket_number, comment)
                status= "CF Automan found multiple company names in the database. Leaving the ticket open for manual completion."
                write_to_gsheet(gscredentials, current_time, ticket_number, status)
                return False
                
            else:
                print(f"Company name '{extracted_company_name}' not found in the database.")
                comment = f"Hmm, I read '{extracted_company_name}' as the company name and couldn't find this company in our Database! So, I am leaving the ticket open for manually completing this task by an agent. Please share feedback in the log linked here so I can understand what happened and learn from it: [CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
                put_ticket_on_open(credentials, ticket_number, comment)
                status= "CF Automan could not find the company name in the database. Leaving the ticket open for manual completion."
                write_to_gsheet(gscredentials, current_time, ticket_number, status)
                return False
        
        #Function to Call GPT       
        def call_gpt(filename):
            # Prompt GPT
            current_dir = os.path.dirname(os.path.abspath(__file__)) # Get the current directory
            filepath = os.path.join(current_dir, filename)
            with open(filepath, 'r') as file:
                prompt = file.read().replace("ticket_description_text", ticket_description_text)
                gptresponse = client.chat.completions.create(
                    model= "gpt-4o", #"gpt-4o" "gpt-4" "gpt-4-turbo"
                    messages=[
                        {"role": "system", "content": "You are a helpful assistant."},
                        {"role": "user", "content": prompt}  # Assuming you want the entire file content as the user's prompt
                    ],
                    max_tokens=2000
                )
                gpt_reply = gptresponse.choices[0].message.content
                return gpt_reply
        
        # def find_description(ticket_number):
        #     print("Finding description")
        #     ticket_description_text = ticket_gen_data['ticket'].get('description', None) 
            
        #     # Regex patterns
        #     date_pattern = r"(\b\d{1,2}(?:st|nd|rd|th)?\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*,\s\d{4}\b|\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s\d{1,2}(?:st|nd|rd|th)?,\s\d{4}\b)"
        #     product_pattern = r"Product:\s(.+)"
        #     company_name_pattern = r"Company Name:\s(.+)"
        #     full_name_pattern = r"Contact Full Name:\s(.+)"
        #     email_pattern = r"Contact Email:\s([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"
        #     cc_pattern = r"CC:\s([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

        #     extracted_data = {
        #         "date": re.search(date_pattern, ticket_description_text).group(1) if re.search(date_pattern, ticket_description_text) else '11/11/1111',
        #         "product": re.search(product_pattern, ticket_description_text).group(1) if re.search(product_pattern, ticket_description_text) else None,
        #         "company_name": re.search(company_name_pattern, ticket_description_text).group(1) if re.search(company_name_pattern, ticket_description_text) else None,
        #         "full_name": re.search(full_name_pattern, ticket_description_text).group(1) if re.search(full_name_pattern, ticket_description_text) else None,
        #         "email": re.search(email_pattern, ticket_description_text).group(1) if re.search(email_pattern, ticket_description_text) else None,
        #         "cc": re.search(cc_pattern, ticket_description_text).group(1) if re.search(cc_pattern, ticket_description_text) else None,
        #     }
            
            # return extracted_data

                # Convert the string into a dictionary using regular expressions
        
        def parse_extracted_data(data):
            parsed_data = {}
            lines = data.split("\n")
            for line in lines:
                match = re.match(r"- (\w+) = \"(.*)\"", line.strip())
                if match:
                    key, value = match.groups()
                    parsed_data[key] = value
            return parsed_data

        ############################################################################################################        
        #### MAIN INITIALIZATION ####
        ############################################################################################################     
        
        # Create a session and authenticate with basic auth
        session = requests.Session()
        credentials = base64.b64encode(f"ai-zd-integration@trilogy.com/token:{ZENDESK_API_KEY}".encode("utf-8")).decode("utf-8")
        session.headers = {
            'Authorization':  f"Basic {credentials}"
        }

        # Make a GET request to retrieve the ticket Brand and Ticket Priority
        response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{ticket_number}.json')    
        
        if response.status_code == 200:
            ticket_gen_data = response.json()
            ticket_description_text = ticket_gen_data['ticket'].get('description', None)
        else:
            print(f"Failed to fetch sc data: {response.status_code}")
        
        # Determine if the ticket is a followup ticket and get the followup ticket number
        if 'via' in ticket_gen_data['ticket'] and 'source' in ticket_gen_data['ticket']['via'] and 'rel' in ticket_gen_data['ticket']['via']['source'] and ticket_gen_data['ticket']['via']['source']['rel'] == 'follow_up':
                followup_ticket = True
                followup_ticket_number = ticket_gen_data['ticket']['via']['source']['from']['ticket_id'] 
        else:
            followup_ticket = False
            followup_ticket_number = None
        
        # Get Ticket Description 
        #ticketDescription = ticket_gen_data['ticket'].get('description', None)
        # extracted_data = find_description(ticket_number)
        # print("extracted data", extracted_data)
        # extracted_expiry_date = extracted_data["date"]
        # extracted_company_name = extracted_data["company_name"]
        # extracted_email = extracted_data["email"]
        
        #ticketDescription using GPT
        extracted_data = call_gpt(filename)

        # Parse the data
        if extracted_data.strip():  # Ensure the string is not empty
            try:
                extracted_data_dict = parse_extracted_data(extracted_data)
            except Exception as e:
                print(f"Error parsing data: {e}")
                extracted_data_dict = {}
        else:
            print("Error: extracted_data is empty!")
            extracted_data_dict = {}

        # Extract fields
        extracted_expiry_date = extracted_data_dict.get("extracted_expiry_date", "UNSURE ABOUT DATE")
        extracted_company_name = extracted_data_dict.get("extracted_company_name", "UNSURE ABOUT COMPANY NAME")
        extracted_email = extracted_data_dict.get("extracted_email", "UNSURE ABOUT EMAIL")

        # Print extracted values for debugging
        print(f"Expiry Date: {extracted_expiry_date}")
        print(f"Company Name: {extracted_company_name}")
        print(f"Email: {extracted_email}")
        
        ############################################################################################################        
        #### MAIN LOGIC ####
        ############################################################################################################    
        
        #                
        
        #if extracted_data["date"] is '11/11/1111' Call GPT to get the date
        # if extracted_expiry_date == '11/11/1111':
        #     global_gpt_reply = call_gpt(filename)
        #     print('GPT:', global_gpt_reply)
            
        #     if "NOT FOUND" in global_gpt_reply:
        #         extracted_expiry_date = '11/11/1111'
        #     else:
        #         extracted_expiry_date = global_gpt_reply
        # else:
        #     pass
        
        if extracted_expiry_date == "MULTIPLE DATES FOUND":
            comment = (
                "I found multiple dates in the ticket description. It is important to have a single date to proceed with the CloudFix Cancellation. \n\nPlease create a new ticket that clearly confirms the following required information for the CloudFix cancellation to move forward:\n\n"
                "Expiry Date: <Add if available, otherwise leave blank or provide a date in the past for automation to perform deactivation immediately>\n"
                "Company Name:\n"
                "Contact Full Name:\n"
                "Contact Email:\n\n"
                "Thank you!"
            )
            put_ticket_on_solved_pr(credentials, ticket_number, comment)
            status= "CF Automan found multiple dates in the ticket description which is not clear to proceed."
            write_to_gsheet(gscredentials, current_time, ticket_number, status)
            #end the script
            return
            
        #check extracted data for {'company_name' and 'email'} if any is missing then open the ticket with comment that data is missing
        if extracted_company_name == "UNSURE ABOUT COMPANY NAME" or extracted_email == "UNSURE ABOUT EMAIL" or extracted_expiry_date == "UNSURE ABOUT DATE":
            if extracted_company_name == "UNSURE ABOUT COMPANY NAME" or extracted_email == "UNSURE ABOUT EMAIL":
                if followup_ticket == False:
                    comment = (
                        "Hi, I could not confirm all the necessary information to proceed with the CloudFix Cancellation. It seems that either the company name or customer's email address is missing. \n\nPlease create a new ticket that clearly confirms the following required information for the CloudFix cancellation to move forward:\n\n"
                        "Expiry Date: <Add if available, otherwise leave blank or provide a date in the past for automation to perform deactivation immediately>\n"
                        "Company Name:\n"
                        "Contact Full Name:\n"
                        "Contact Email:\n\n"
                        "Thank you!"
                    )
                    put_ticket_on_solved_pr(credentials, ticket_number, comment)
                    status= "CF Automan did not find either the company name or the customer's email which are vital to complete this request."
                    write_to_gsheet(gscredentials, current_time, ticket_number, status)
                    return
                
                else: #if followup_ticket == True:      
                    # Check the description of the followup ticket
                    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{followup_ticket_number}.json')
                    if response.status_code == 200:
                        ticket_gen_data = response.json()
                        ticket_description_text = ticket_gen_data['ticket'].get('description', None)
                    else:
                        print(f"Failed to fetch sc data: {response.status_code}")   
                    
                    #ticketDescription using GPT
                    extracted_data = call_gpt(filename)

                    # Parse the data
                    if extracted_data.strip():  # Ensure the string is not empty
                        try:
                            extracted_data_dict = parse_extracted_data(extracted_data)
                        except Exception as e:
                            print(f"Error parsing data: {e}")
                            extracted_data_dict = {}
                    else:
                        print("Error: extracted_data is empty!")
                        extracted_data_dict = {}

                    # Extract fields
                    extracted_expiry_date = extracted_data_dict.get("extracted_expiry_date", "UNSURE ABOUT DATE")
                    extracted_company_name = extracted_data_dict.get("extracted_company_name", "UNSURE ABOUT COMPANY NAME")
                    extracted_email = extracted_data_dict.get("extracted_email", "UNSURE ABOUT EMAIL")

                    # Print extracted values for debugging
                    print(f"Expiry Date in the previous Followup Ticket: {extracted_expiry_date}")
                    print(f"Company Name in the previous Followup Ticket: {extracted_company_name}")
                    print(f"Email in the previous Followup Ticket: {extracted_email}")
            
                    if extracted_company_name == "UNSURE ABOUT COMPANY NAME" or extracted_email == "UNSURE ABOUT EMAIL":
                        comment = (
                            "Hi, I could not confirm all the necessary information to proceed with the CloudFix Cancellation. It seems crucial informarion is missing. \n\nPlease create a new ticket that clearly confirms the following required information for the CloudFix cancellation to move forward:\n\n"
                            "Expiry Date: <Add if available, otherwise leave blank or provide a date in the past for automation to perform deactivation immediately>\n"
                            "Company Name:\n"
                            "Contact Full Name:\n"
                            "Contact Email:\n\n"
                            "Thank you!"
                        )
                        put_ticket_on_solved_pr(credentials, ticket_number, comment)
                        status= "CF Automan did not find either the company name or the customer's email which are vital to complete this request. I also checked the previous linked ticket."
                        write_to_gsheet(gscredentials, current_time, ticket_number, status)
                        #stop the script
                        return
                    else:
                        pass
            
            elif extracted_expiry_date == "UNSURE ABOUT DATE":
                if followup_ticket == False:
                    pass
                
                else: #if followup_ticket == True:      
                    # Check the description of the followup ticket
                    response = session.get(f'https://central-supportdesk.zendesk.com/api/v2/tickets/{followup_ticket_number}.json')
                    if response.status_code == 200:
                        ticket_gen_data = response.json()
                        ticket_description_text = ticket_gen_data['ticket'].get('description', None)
                    else:
                        print(f"Failed to fetch sc data: {response.status_code}")   
                    
                    #ticketDescription using GPT
                    extracted_data = call_gpt(filename)

                    # Parse the data
                    if extracted_data.strip():  # Ensure the string is not empty
                        try:
                            extracted_data_dict = parse_extracted_data(extracted_data)
                        except Exception as e:
                            print(f"Error parsing data: {e}")
                            extracted_data_dict = {}
                    else:
                        print("Error: extracted_data is empty!")
                        extracted_data_dict = {}

                    # Extract fields
                    extracted_expiry_date = extracted_data_dict.get("extracted_expiry_date", "UNSURE ABOUT DATE")

                    # Print extracted values for debugging
                    print(f"Expiry Date in the previous Followup Ticket: {extracted_expiry_date}")
            else:
                pass
        else:
            pass
        
        #if no date then set a past date
        if extracted_expiry_date == "UNSURE ABOUT DATE": 
           extracted_expiry_date = "11/11/1111"
        else:
            pass
        
        #Set folowup if extracted_expiry_date is in the future or deprovision if date is in the past    
        if is_future_date(extracted_expiry_date):
            print("future date!")
            #add_tag_to_ticket(ticket_number, "Future Expiry Date")

            followup_date = None
            for date_format in date_formats:
                extracted_expiry_date = str(extracted_expiry_date)
                try:
                    followup_date = datetime.strptime(extracted_expiry_date, date_format).strftime("%m/%d/%Y")
                    break  # Exit the loop if a valid format is found
                except ValueError:
                    continue  # Try the next format

            if followup_date is None:
                print(f"Date format for '{extracted_expiry_date}' is not recognized.")
                raise ValueError(f"Date format for '{extracted_expiry_date}' is not recognized.")
            else:
                print(f"Follow-up date: {followup_date}")
                write_to_scheduler_gsheet(gscredentials, ticket_number, followup_date)
                comment = "Hi, I found a future deprovisioning date. So, I have added this deprovisioning task to the [Follow-Up Scheduler](https://docs.google.com/spreadsheets/d/1p2_qDgt8CwL3_hB5vEdKba3XC4TAbm8CL7IOS-lAeEg/edit?usp=sharing).\n\n Thank you!"
                put_ticket_on_solved_pr(credentials, ticket_number, comment)
                status= "CF Automan found a future deprovisioning date and added it to the Follow-Up Scheduler."
                write_to_gsheet(gscredentials, current_time, ticket_number, status)
                return
            
        else:
            print(f"deprovisioning {extracted_company_name}")
            logging.basicConfig(level=logging.ERROR)
            try:
                with pymysql.connect(
                    user=DB_USER,
                    password=DB_PASSWORD,
                    host=DB_HOST,
                    port=DB_PORT,
                    database=DB_NAME
                ) as conn:
                    with conn.cursor() as cursor:
                        extracted_company_name = str(extracted_company_name)
                        deprovision_instance(cursor, extracted_company_name)
                        conn.commit()
            except pymysql.MySQLError as err:
                logging.error(f"Database Error: {err}")
                raise Exception("Database Error")
            except Exception as err:
                logging.error(f"An unexpected error occurred during provisioning: {err}")
                raise Exception("An unexpected error occurred")
            return

    
    ##############################################################################################
    #### EXCEPTION HANDLING ####
    ##############################################################################################
    
    except Exception as e:
        status = "An unexpected error occurred"
        
        if "Invalid" in str(e):
            status = "Invalid auth or ticket number provided in the request body"
            print(f"{str(e)}")
        
        elif "Multiple runs detected" in str(e):
            status = "Lamda multi-run detected and stopped using DBB."
            print(f"{str(e)}")
        
        elif "Database" in str(e):
            print(f"Database exception occurred on the ticket {ticket_number}: {str(e)}")
            comment = "Oops, looks like I encountered a bit of a snag while deprovisioning! So, I am leaving the ticket open for manually completing this task by an agent. Please share feedback in the log linked here so I can understand what happened and learn from it: [CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
            status = "CF Automation encountered a bit of a snag while deprovisioning"
            put_ticket_on_open(credentials, ticket_number, comment)
        
        elif "Google API error" in str(e):
            print(f"Google API exception occurred on the ticket {ticket_number}: {str(e)}")
            comment = "Oops, looks like I encountered a bit of a snag! So, I am leaving the ticket open for manually completing this task by an agent. Please share feedback in the log linked here so I can understand what happened and learn from it: [CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
            status = "CF Automation encountered a bit of a snag with Google API"
            put_ticket_on_open(credentials, ticket_number, comment)
        
        elif "Date format" in str(e):
            print(f"Date format exception occurred on the ticket {ticket_number}: {str(e)}")
            comment = "Oops, looks like I encountered a bit of a snag while processing the date! So, I am leaving the ticket open for manually completing this task by an agent. Please share feedback in the log linked here so I can understand what happened and learn from it: [CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
            status = "CF Automation encountered a bit of a snag while processing the date"
            put_ticket_on_open(credentials, ticket_number, comment)
        
        else:
            print(f"Lamda exception occurred on the ticket {ticket_number}: {str(e)}")
            comment = "Oops, looks like I encountered a bit of a snag! So, I am leaving the ticket open for manually completing this task by an agent. Please share feedback in the log linked here so I can understand what happened and learn from it: [CF-DeprovAutomanLog](https://docs.google.com/spreadsheets/d/1r-jUET6tchc3GhWGtH2TPDczV-_jKQgF7B6mAY9VbZY/edit?usp=sharing)"
            status = "CF Automation encountered a bit of a snag"
            put_ticket_on_open(credentials, ticket_number, comment)
        
        write_to_gsheet(gscredentials, current_time, ticket_number, status)
